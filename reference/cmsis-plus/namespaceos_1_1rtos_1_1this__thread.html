<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CMSIS++ Reference: os::rtos::this_thread Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-16767008-14', 'auto');
  ga('send', 'pageview');
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="$relpath/../../../.."><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign">
   <div>
     <div id="projectname">CMSIS++ Reference
     &#160;<span id="projectnumber">0.1.1</span>
     </div>
     <div id="projectmotto" class="float:right;">“Perfekt ist nicht gut genug”</div>
     </div>  
   </div>
   <div id="projectbrief">CMSIS++: A proposal for the next generation CMSIS, written in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceos_1_1rtos_1_1this__thread.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">os::rtos::this_thread Namespace Reference<div class="ingroups"><a class="el" href="group__cmsis-plus-rtos.html">CMSIS++ RTOS C++ API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A convenience namespace to access the current running thread.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3c889c1521abca1ffb23bc42bd6ccc10"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a3c889c1521abca1ffb23bc42bd6ccc10">error</a> (void)</td></tr>
<tr class="memdesc:a3c889c1521abca1ffb23bc42bd6ccc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the library <code><a class="el" href="group__cmsis-plus-rtos.html#gacd1274564a12e4054b2b4532becaff85" title="Per-thread error support. ">__error()</a></code> function.  <a href="#a3c889c1521abca1ffb23bc42bd6ccc10">More...</a><br /></td></tr>
<tr class="separator:a3c889c1521abca1ffb23bc42bd6ccc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c68164be854d7fb8a2693726c6207ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a9c68164be854d7fb8a2693726c6207ff">exit</a> (void *exit_ptr=nullptr)</td></tr>
<tr class="memdesc:a9c68164be854d7fb8a2693726c6207ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the current running thread.  <a href="#a9c68164be854d7fb8a2693726c6207ff">More...</a><br /></td></tr>
<tr class="separator:a9c68164be854d7fb8a2693726c6207ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5101a855f1eced8c611bfba34778c92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#ab5101a855f1eced8c611bfba34778c92">is_timeout</a> (void)</td></tr>
<tr class="memdesc:ab5101a855f1eced8c611bfba34778c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the wake-up is due to a timeout.  <a href="#ab5101a855f1eced8c611bfba34778c92">More...</a><br /></td></tr>
<tr class="separator:ab5101a855f1eced8c611bfba34778c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23a950fc1aba831bbe97a0ae612d43f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#aa23a950fc1aba831bbe97a0ae612d43f">join</a> (<a class="el" href="classos_1_1rtos_1_1thread.html">rtos::thread</a> &amp;<a class="el" href="classos_1_1rtos_1_1thread.html">thread</a>, void **exit_ptr=nullptr)</td></tr>
<tr class="memdesc:aa23a950fc1aba831bbe97a0ae612d43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for thread termination.  <a href="#aa23a950fc1aba831bbe97a0ae612d43f">More...</a><br /></td></tr>
<tr class="separator:aa23a950fc1aba831bbe97a0ae612d43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f1f205a2cc6d9e2e0def9bf0a20002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a95f1f205a2cc6d9e2e0def9bf0a20002">sig_wait</a> (sigset_t mask, sigset_t *oflags=nullptr, <a class="el" href="group__cmsis-plus-rtos.html#ga49c1da8337c9d32697fefbdf0412cdac">flags::mode_t</a> mode=<a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa0efea2cf0731279e9b4aa341820582a2">flags::mode::all</a>|<a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa71559e3634890b5547e62ff93160ac3a">flags::mode::clear</a>)</td></tr>
<tr class="memdesc:a95f1f205a2cc6d9e2e0def9bf0a20002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for signal flags.  <a href="#a95f1f205a2cc6d9e2e0def9bf0a20002">More...</a><br /></td></tr>
<tr class="separator:a95f1f205a2cc6d9e2e0def9bf0a20002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60661f0e3a2380c9afbec42c3b505bc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classos_1_1rtos_1_1thread.html">thread</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a60661f0e3a2380c9afbec42c3b505bc4">thread</a> (void)</td></tr>
<tr class="memdesc:a60661f0e3a2380c9afbec42c3b505bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current running thread.  <a href="#a60661f0e3a2380c9afbec42c3b505bc4">More...</a><br /></td></tr>
<tr class="separator:a60661f0e3a2380c9afbec42c3b505bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7c062b71bf2789732a8d5fad934db6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a4f7c062b71bf2789732a8d5fad934db6">timed_sig_wait</a> (sigset_t mask, <a class="el" href="classos_1_1rtos_1_1clock.html#a149d8b5cea55224ef5cfede8a81df04c">clock::duration_t</a> timeout, sigset_t *oflags=nullptr, <a class="el" href="group__cmsis-plus-rtos.html#ga49c1da8337c9d32697fefbdf0412cdac">flags::mode_t</a> mode=<a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa0efea2cf0731279e9b4aa341820582a2">flags::mode::all</a>|<a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa71559e3634890b5547e62ff93160ac3a">flags::mode::clear</a>)</td></tr>
<tr class="memdesc:a4f7c062b71bf2789732a8d5fad934db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed wait for signal flags.  <a href="#a4f7c062b71bf2789732a8d5fad934db6">More...</a><br /></td></tr>
<tr class="separator:a4f7c062b71bf2789732a8d5fad934db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0340892d2f41a4ac6895b555a8ff549f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a0340892d2f41a4ac6895b555a8ff549f">try_sig_wait</a> (sigset_t mask, sigset_t *oflags=nullptr, <a class="el" href="group__cmsis-plus-rtos.html#ga49c1da8337c9d32697fefbdf0412cdac">flags::mode_t</a> mode=<a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa0efea2cf0731279e9b4aa341820582a2">flags::mode::all</a>|<a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa71559e3634890b5547e62ff93160ac3a">flags::mode::clear</a>)</td></tr>
<tr class="memdesc:a0340892d2f41a4ac6895b555a8ff549f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to wait for signal flags.  <a href="#a0340892d2f41a4ac6895b555a8ff549f">More...</a><br /></td></tr>
<tr class="separator:a0340892d2f41a4ac6895b555a8ff549f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51171b707af828d3a3ce7b3cf89e7d4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a51171b707af828d3a3ce7b3cf89e7d4c">wait</a> (void)</td></tr>
<tr class="memdesc:a51171b707af828d3a3ce7b3cf89e7d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend the current running thread to wait for an event.  <a href="#a51171b707af828d3a3ce7b3cf89e7d4c">More...</a><br /></td></tr>
<tr class="separator:a51171b707af828d3a3ce7b3cf89e7d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6b2df07994ab81b2435596a93bbdb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a6d6b2df07994ab81b2435596a93bbdb6">yield</a> (void)</td></tr>
<tr class="memdesc:a6d6b2df07994ab81b2435596a93bbdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield execution to the next ready thread.  <a href="#a6d6b2df07994ab81b2435596a93bbdb6">More...</a><br /></td></tr>
<tr class="separator:a6d6b2df07994ab81b2435596a93bbdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A convenience namespace to access the current running thread. </p>
<p>The <a class="el" href="namespaceos_1_1rtos_1_1this__thread.html" title="A convenience namespace to access the current running thread. ">os::rtos::this_thread</a> namespace groups functions related to the current thread. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3c889c1521abca1ffb23bc42bd6ccc10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int * os::rtos::this_thread::error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the library <code><a class="el" href="group__cmsis-plus-rtos.html#gacd1274564a12e4054b2b4532becaff85" title="Per-thread error support. ">__error()</a></code> function. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to thread specific <code>errno</code>.</dd></dl>
<p>The actual C library function, used by newlib, is in <code><a class="el" href="os-core_8cpp.html">os-core.cpp</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cmsis-plus-rtos.html#gacd1274564a12e4054b2b4532becaff85" title="Per-thread error support. ">__error()</a> </dd></dl>

<p>Definition at line <a class="el" href="os-thread_8h_source.html#l01704">1704</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9c68164be854d7fb8a2693726c6207ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::this_thread::exit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>exit_ptr</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminate the current running thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exit_ptr</td><td>Pointer to object to return. (Optional). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Terminate the calling thread and make the value <em>value_ptr</em> available to any successful join with the terminating thread. Any cancellation cleanup handlers that have been pushed and not yet popped shall be popped in the reverse order that they were pushed and then executed. After all cancellation cleanup handlers have been executed, if the thread has any thread-specific data, appropriate destructor functions shall be called in an unspecified order. Thread termination does not release any application visible process resources, including, but not limited to, mutexes and file descriptors, nor does it perform any process-level cleanup actions, including, but not limited to, calling any <code>atexit()</code> routines that may exist. An implicit call to <a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a9c68164be854d7fb8a2693726c6207ff" title="Terminate the current running thread. ">exit()</a> is made when a thread other than the thread in which <a class="el" href="os-main_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title="Default implementation of main(). ">main()</a> was first invoked returns from the start routine that was used to create it. The function's return value shall serve as the thread's exit status. The behaviour of <code>_exit()</code> is undefined if called from a cancellation cleanup handler or destructor function that was invoked as a result of either an implicit or explicit call to <code><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a9c68164be854d7fb8a2693726c6207ff" title="Terminate the current running thread. ">exit()</a></code>. After a thread has terminated, the result of access to local (auto) variables of the thread is undefined. Thus, references to local variables of the exiting thread should not be used for the <code><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a9c68164be854d7fb8a2693726c6207ff" title="Terminate the current running thread. ">exit()</a></code> <em>value_ptr</em> parameter value.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_exit.html"><code>pthread_exit()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-thread_8h_source.html#l01689">1689</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab5101a855f1eced8c611bfba34778c92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool os::rtos::this_thread::is_timeout </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the wake-up is due to a timeout. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The previous sleep returned after the entire duration. </td></tr>
    <tr><td class="paramname">false</td><td>The previous sleep returned due to an event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa23a950fc1aba831bbe97a0ae612d43f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::this_thread::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1thread.html">rtos::thread</a> &amp;&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>exit_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for thread termination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>Reference to terminating thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exit_ptr</td><td>Pointer to object to return. (Optional). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a3d19f716a55045807932fbda5ad85724ac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The thread was terminated. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines.</td></tr>
  </table>
  </dd>
</dl>
<p>Suspend execution of the calling thread until the target thread terminates, unless the target thread has already terminated. On return from a successful <code><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#aa23a950fc1aba831bbe97a0ae612d43f" title="Wait for thread termination. ">join()</a></code> call with a non-NULL <em>exit_ptr</em> argument, the value passed to <a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a9c68164be854d7fb8a2693726c6207ff" title="Terminate the current running thread. ">exit()</a> by the terminating thread shall be made available in the location referenced by <em>exit_ptr</em>. When a <code><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#aa23a950fc1aba831bbe97a0ae612d43f" title="Wait for thread termination. ">join()</a></code> returns successfully, the target thread has been terminated. The results of multiple simultaneous calls to <code><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#aa23a950fc1aba831bbe97a0ae612d43f" title="Wait for thread termination. ">join()</a></code> specifying the same target thread are undefined. If the thread calling <code><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#aa23a950fc1aba831bbe97a0ae612d43f" title="Wait for thread termination. ">join()</a></code> is cancelled, then the target thread shall not be detached.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_join.html"><code>pthread_join()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<p>The <a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#aa23a950fc1aba831bbe97a0ae612d43f" title="Wait for thread termination. ">join()</a> function may fail if: [EDEADLK] A deadlock was detected.</p>
<p>The <code><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#aa23a950fc1aba831bbe97a0ae612d43f" title="Wait for thread termination. ">join()</a></code> function shall not return an error code of [EINTR].</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-thread_8cpp_source.html#l01279">1279</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a95f1f205a2cc6d9e2e0def9bf0a20002"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::this_thread::sig_wait </td>
          <td>(</td>
          <td class="paramtype">sigset_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigset_t *&#160;</td>
          <td class="paramname"><em>oflags</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cmsis-plus-rtos.html#ga49c1da8337c9d32697fefbdf0412cdac">flags::mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa0efea2cf0731279e9b4aa341820582a2">flags::mode::all</a>&#160;|&#160;<a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa71559e3634890b5547e62ff93160ac3a">flags::mode::clear</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for signal flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>The expected flags (OR-ed bit-mask); may be zero. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oflags</td><td>Pointer where to store the current flags; may be <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode bits to select if either all or any flags are expected, and if the flags should be cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a3d19f716a55045807932fbda5ad85724ac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>All expected flags are raised. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The mask is outside of the permitted range. </td></tr>
    <tr><td class="paramname">EINTR</td><td>The operation was interrupted. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>Wait failed.</td></tr>
  </table>
  </dd>
</dl>
<p>If the <a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa0efea2cf0731279e9b4aa341820582a2" title="Return when all flags are set. ">flags::mode::all</a> bit is set, the function expects all given flags to be raised; otherwise, if the <a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aab708645ba400c7eaa8a0a22a25322339" title="Return when at least one flag is set. ">flags::mode::any</a> bit is set, the function expects any single flag to be raised.</p>
<p>If the expected signal flags are raised, the function returns instantly.</p>
<p>Otherwise suspend the execution of the current thread until all/any specified signal flags are raised.</p>
<p>When the parameter mask is 0, the thread is suspended until any signal flag is raised. In this case, if any signal flags are already raised, the function returns instantly.</p>
<p>If the <a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa71559e3634890b5547e62ff93160ac3a" title="Ask for flags to be cleared after read. ">flags::mode::clear</a> bit is set, the signal flags that are returned are automatically cleared.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-thread_8h_source.html#l01583">1583</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a class="anchor" id="a60661f0e3a2380c9afbec42c3b505bc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classos_1_1rtos_1_1thread.html">rtos::thread</a> &amp; os::rtos::this_thread::thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current running thread. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the current running thread.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-thread_8cpp_source.html#l01200">1200</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f7c062b71bf2789732a8d5fad934db6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::this_thread::timed_sig_wait </td>
          <td>(</td>
          <td class="paramtype">sigset_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1clock.html#a149d8b5cea55224ef5cfede8a81df04c">clock::duration_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigset_t *&#160;</td>
          <td class="paramname"><em>oflags</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cmsis-plus-rtos.html#ga49c1da8337c9d32697fefbdf0412cdac">flags::mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa0efea2cf0731279e9b4aa341820582a2">flags::mode::all</a>&#160;|&#160;<a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa71559e3634890b5547e62ff93160ac3a">flags::mode::clear</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timed wait for signal flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>The expected flags (OR-ed bit-mask); may be zero. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oflags</td><td>Pointer where to store the current flags; may be <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode bits to select if either all or any flags are expected, and if the flags should be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout to wait, in clock units (ticks or seconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a3d19f716a55045807932fbda5ad85724ac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>All expected flags are raised. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">ETIMEDOUT</td><td>The expected condition did not occur during the entire timeout duration. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The mask is outside of the permitted range. </td></tr>
    <tr><td class="paramname">EINTR</td><td>The operation was interrupted. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>Wait failed.</td></tr>
  </table>
  </dd>
</dl>
<p>If the <a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa0efea2cf0731279e9b4aa341820582a2" title="Return when all flags are set. ">flags::mode::all</a> bit is set, the function expects all given flags to be raised; otherwise, if the <a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aab708645ba400c7eaa8a0a22a25322339" title="Return when at least one flag is set. ">flags::mode::any</a> bit is set, the function expects any single flag to be raised.</p>
<p>If the expected signal flags are raised, the function returns instantly.</p>
<p>Otherwise suspend the execution of the thread until all/any specified signal flags are raised.</p>
<p>When the parameter mask is 0, the thread is suspended until any event flag is raised. In this case, if any signal flags are already raised, the function returns instantly.</p>
<p>The wait shall be terminated when the specified timeout expires.</p>
<p>The timeout shall expire after the number of time units (that is when the value of that clock equals or exceeds (<a class="el" href="namespaceos_1_1estd_1_1chrono.html#aa72a3cdebba9461616eb9cd1295bf666">now()</a>+duration). The resolution of the timeout shall be the resolution of the clock on which it is based (the SysTick clock for CMSIS).</p>
<p>Under no circumstance shall the operation fail with a timeout if the signal flags are already raised. The validity of the timeout need not be checked if the expected flags are already raised and the call can return immediately.</p>
<p>The clock used for timeouts can be specified via the <code>clock</code> attribute. By default, the clock derived from the scheduler timer is used, and the durations are expressed in ticks.</p>
<p>If the <a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa71559e3634890b5547e62ff93160ac3a" title="Ask for flags to be cleared after read. ">flags::mode::clear</a> bit is set, the signal flags that are returned are automatically cleared.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-thread_8h_source.html#l01644">1644</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0340892d2f41a4ac6895b555a8ff549f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::this_thread::try_sig_wait </td>
          <td>(</td>
          <td class="paramtype">sigset_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigset_t *&#160;</td>
          <td class="paramname"><em>oflags</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cmsis-plus-rtos.html#ga49c1da8337c9d32697fefbdf0412cdac">flags::mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa0efea2cf0731279e9b4aa341820582a2">flags::mode::all</a>&#160;|&#160;<a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa71559e3634890b5547e62ff93160ac3a">flags::mode::clear</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to wait for signal flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>The expected flags (OR-ed bit-mask); may be zero. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oflags</td><td>Pointer where to store the current flags; may be <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode bits to select if either all or any flags are expected, and if the flags should be cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a3d19f716a55045807932fbda5ad85724ac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>All expected flags are raised. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The mask is outside of the permitted range. </td></tr>
    <tr><td class="paramname">EWOULDBLOCK</td><td>The expected condition did not occur. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>Wait failed.</td></tr>
  </table>
  </dd>
</dl>
<p>If the <a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aa0efea2cf0731279e9b4aa341820582a2" title="Return when all flags are set. ">flags::mode::all</a> bit is set, the function expects all given flags to be raised; otherwise, if the <a class="el" href="group__cmsis-plus-rtos.html#gga1472154078ef02cfa5f62ae1ca50758aab708645ba400c7eaa8a0a22a25322339" title="Return when at least one flag is set. ">flags::mode::any</a> bit is set, the function expects any single flag to be raised.</p>
<p>The function does not blocks, if the expected signal flags are not raised, but returns <code>EGAIN</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-thread_8h_source.html#l01600">1600</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a class="anchor" id="a51171b707af828d3a3ce7b3cf89e7d4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::this_thread::wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspend the current running thread to wait for an event. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Remove the current running thread from the ready list and pass control to the next ready thread. The thread will not be automatically rescheduled, it requires some other tread or interrupt service routine to add it back to the READY state (via <code><a class="el" href="classos_1_1rtos_1_1thread.html#aea39969a90aad5de97abc2529485c18c" title="Resume the thread. ">thread::resume()</a></code>).</p>
<p>This is different from <code><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html#a6d6b2df07994ab81b2435596a93bbdb6" title="Yield execution to the next ready thread. ">yield()</a></code> which automatically reschedules the current thread before passing control to the next thread (which might be the same if no other threads with at least the same priority are ready).</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-thread_8h_source.html#l01556">1556</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6d6b2df07994ab81b2435596a93bbdb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::this_thread::yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield execution to the next ready thread. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Pass control to next thread that is in <b>READY</b> state.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-thread_8cpp_source.html#l01219">1219</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceos.html">os</a></li><li class="navelem"><a class="el" href="namespaceos_1_1rtos.html">rtos</a></li><li class="navelem"><a class="el" href="namespaceos_1_1rtos_1_1this__thread.html">this_thread</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
