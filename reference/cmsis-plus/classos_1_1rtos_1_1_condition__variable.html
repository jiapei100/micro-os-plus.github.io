<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CMSIS++ Reference: os::rtos::Condition_variable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-16767008-14', 'auto');
  ga('send', 'pageview');
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="$relpath/../../../.."><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign">
   <div>
     <div id="projectname">CMSIS++ Reference
     &#160;<span id="projectnumber">0.1.1</span>
     </div>
     <div id="projectmotto" class="float:right;">“Perfekt ist nicht gut genug”</div>
     </div>  
   </div>
   <div id="projectbrief">CMSIS++: A proposal for the next generation CMSIS, written in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classos_1_1rtos_1_1_condition__variable.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classos_1_1rtos_1_1_condition__variable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">os::rtos::Condition_variable Class Reference<div class="ingroups"><a class="el" href="group__cmsis-plus-rtos.html">CMSIS++ RTOS API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>POSIX compliant <b>condition variable</b>.  
 <a href="classos_1_1rtos_1_1_condition__variable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="os_8h_source.html">cmsis-plus/rtos/os.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="classos_1_1rtos_1_1_named__object.html">os::rtos::Named_object</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors &amp; Destructor</div></td></tr>
<tr class="memitem:a529d67d9f3d8b7dddba6ef37daec9ad4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a529d67d9f3d8b7dddba6ef37daec9ad4">Condition_variable</a> ()</td></tr>
<tr class="memdesc:a529d67d9f3d8b7dddba6ef37daec9ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a condition variable with default settings.  <a href="#a529d67d9f3d8b7dddba6ef37daec9ad4">More...</a><br /></td></tr>
<tr class="separator:a529d67d9f3d8b7dddba6ef37daec9ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbee5659b170c813849cb3eb13c7d4d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#acbee5659b170c813849cb3eb13c7d4d9">Condition_variable</a> (const <a class="el" href="classos_1_1rtos_1_1condvar_1_1_attributes.html">condvar::Attributes</a> &amp;attr)</td></tr>
<tr class="memdesc:acbee5659b170c813849cb3eb13c7d4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a condition variable with custom settings.  <a href="#acbee5659b170c813849cb3eb13c7d4d9">More...</a><br /></td></tr>
<tr class="separator:acbee5659b170c813849cb3eb13c7d4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955df145b56aa6b874f82c1fc1248bbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a955df145b56aa6b874f82c1fc1248bbf">~Condition_variable</a> ()</td></tr>
<tr class="memdesc:a955df145b56aa6b874f82c1fc1248bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a condition variable.  <a href="#a955df145b56aa6b874f82c1fc1248bbf">More...</a><br /></td></tr>
<tr class="separator:a955df145b56aa6b874f82c1fc1248bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:a2ec8f18bdeebd7e5cfa9246542258775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a2ec8f18bdeebd7e5cfa9246542258775">operator==</a> (const <a class="el" href="classos_1_1rtos_1_1_condition__variable.html">Condition_variable</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a2ec8f18bdeebd7e5cfa9246542258775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare condition variables.  <a href="#a2ec8f18bdeebd7e5cfa9246542258775">More...</a><br /></td></tr>
<tr class="separator:a2ec8f18bdeebd7e5cfa9246542258775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a3d473424e6a4d29b02bed96f471ff95a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a3d473424e6a4d29b02bed96f471ff95a">signal</a> (void)</td></tr>
<tr class="memdesc:a3d473424e6a4d29b02bed96f471ff95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify one thread waiting for a condition variable.  <a href="#a3d473424e6a4d29b02bed96f471ff95a">More...</a><br /></td></tr>
<tr class="separator:a3d473424e6a4d29b02bed96f471ff95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab539df006aae5109e8a94e871d29fb0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e">broadcast</a> (void)</td></tr>
<tr class="memdesc:ab539df006aae5109e8a94e871d29fb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify all threads waiting for a condition variable.  <a href="#ab539df006aae5109e8a94e871d29fb0e">More...</a><br /></td></tr>
<tr class="separator:ab539df006aae5109e8a94e871d29fb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb95476af3012f02b138dbcd5931214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214">wait</a> (<a class="el" href="classos_1_1rtos_1_1_mutex.html">Mutex</a> &amp;mutex)</td></tr>
<tr class="memdesc:a7fb95476af3012f02b138dbcd5931214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a condition variable to be notified.  <a href="#a7fb95476af3012f02b138dbcd5931214">More...</a><br /></td></tr>
<tr class="separator:a7fb95476af3012f02b138dbcd5931214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ce637cd4aaee2e34d72ee8f1d5f16f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f">timed_wait</a> (<a class="el" href="classos_1_1rtos_1_1_mutex.html">Mutex</a> &amp;mutex, <a class="el" href="namespaceos_1_1rtos_1_1clock.html#a61ab6fb2482ab2d9ef03f6e0aa445287">clock::duration_t</a> timeout)</td></tr>
<tr class="memdesc:aa7ce637cd4aaee2e34d72ee8f1d5f16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed wait for a condition variable to be notified.  <a href="#aa7ce637cd4aaee2e34d72ee8f1d5f16f">More...</a><br /></td></tr>
<tr class="separator:aa7ce637cd4aaee2e34d72ee8f1d5f16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a1ced578ffc847e14547b02ee1473c44e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_named__object.html#a1ced578ffc847e14547b02ee1473c44e">name</a> (void) const </td></tr>
<tr class="memdesc:a1ced578ffc847e14547b02ee1473c44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name.  <a href="#a1ced578ffc847e14547b02ee1473c44e">More...</a><br /></td></tr>
<tr class="separator:a1ced578ffc847e14547b02ee1473c44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Member Variables</div></td></tr>
<tr class="memitem:aa5d2137667e086514699c240abf2772a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classos_1_1rtos_1_1_waiting__threads__list.html">Waiting_threads_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa5d2137667e086514699c240abf2772a">list_</a></td></tr>
<tr class="separator:aa5d2137667e086514699c240abf2772a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Member Variables</div></td></tr>
<tr class="memitem:ad7667db8bf3171d900237500cb0e1e67"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_named__object.html#ad7667db8bf3171d900237500cb0e1e67">name_</a></td></tr>
<tr class="memdesc:ad7667db8bf3171d900237500cb0e1e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to name.  <a href="#ad7667db8bf3171d900237500cb0e1e67">More...</a><br /></td></tr>
<tr class="separator:ad7667db8bf3171d900237500cb0e1e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>POSIX compliant <b>condition variable</b>. </p>
<p>A condition variable is a synchronisation object which allows a thread to suspend execution, repeatedly, until some associated predicate becomes true. A thread whose execution is suspended on a condition variable is said to be blocked on the condition variable.</p>
<dl class="section user"><dt>Scheduling Behaviour of Condition Variables</dt><dd></dd></dl>
<p>Synchronisation primitives that attempt to interfere with scheduling policy by specifying an ordering rule are considered undesirable. Threads waiting on mutexes and condition variables are selected to proceed in an order dependent upon the scheduling policy rather than in some fixed order (for example, FIFO or priority). Thus, the scheduling policy determines which thread(s) are awakened and allowed to proceed.</p>
<dl class="section user"><dt>Cancellation and Condition Wait</dt><dd></dd></dl>
<p>A condition wait, whether timed or not, is a cancellation point. That is, the functions <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code> are points where a pending (or concurrent) cancellation request is noticed. The reason for this is that an indefinite wait is possible at these points-whatever event is being waited for, even if the program is totally correct, might never occur; for example, some input data being awaited might never be sent. By making condition wait a cancellation point, the thread can be cancelled and perform its cancellation cleanup handler even though it may be stuck in some indefinite wait.</p>
<p>A side-effect of acting on a cancellation request while a thread is blocked on a condition variable is to re-acquire the mutex before calling any of the cancellation cleanup handlers. This is done in order to ensure that the cancellation cleanup handler is executed in the same state as the critical code that lies both before and after the call to the condition wait function. This rule is also required when interfacing to POSIX threads from languages, such as Ada or C++, which may choose to map cancellation onto a language exception; this rule ensures that each exception handler guarding a critical section can always safely depend upon the fact that the associated mutex has already been locked regardless of exactly where within the critical section the exception was raised. Without this rule, there would not be a uniform rule that exception handlers could follow regarding the lock, and so coding would become very cumbersome.</p>
<p>Therefore, since some statement has to be made regarding the state of the lock when a cancellation is delivered during a wait, a definition has been chosen that makes application coding most convenient and error free.</p>
<p>When acting on a cancellation request while a thread is blocked on a condition variable, the implementation is required to ensure that the thread does not consume any condition signals directed at that condition variable if there are any other threads waiting on that condition variable. This rule is specified in order to avoid deadlock conditions that could occur if these two independent requests (one acting on a thread and the other acting on the condition variable) were not processed independently.</p>
<dl class="section user"><dt>Performance of Mutexes and Condition Variables</dt><dd></dd></dl>
<p>Mutexes are expected to be locked only for a few instructions. This practice is almost automatically enforced by the desire of programmers to avoid long serial regions of execution (which would reduce total effective parallelism).</p>
<p>When using mutexes and condition variables, one tries to ensure that the usual case is to lock the mutex, access shared data, and unlock the mutex. Waiting on a condition variable should be a relatively rare situation. For example, when implementing a read-write lock, code that acquires a read-lock typically needs only to increment the count of readers (under mutual-exclusion) and return. The calling thread would actually wait on the condition variable only when there is already an active writer. So the efficiency of a synchronisation operation is bounded by the cost of mutex lock/unlock and not by condition wait. Note that in the usual case there is no context switch.</p>
<p>This is not to say that the efficiency of condition waiting is unimportant. Since there needs to be at least one context switch per Ada rendezvous, the efficiency of waiting on a condition variable is important. The cost of waiting on a condition variable should be little more than the minimal cost for a context switch plus the time to unlock and lock the mutex.</p>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<div class="fragment"><div class="line">Mutex mx;</div><div class="line"><a class="code" href="classos_1_1rtos_1_1_condition__variable.html#a529d67d9f3d8b7dddba6ef37daec9ad4">Condition_variable</a> cv;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">consumer(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// Do something</span></div><div class="line">  mx.lock();</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keywordflow">while</span>(!condition())</div><div class="line">    {</div><div class="line">      <span class="comment">// ...</span></div><div class="line">      cv.wait();</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  mx.unlock(mx);</div><div class="line">  <span class="comment">// Do something else.</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">producer(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// Do something</span></div><div class="line">  mx.lock();</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keywordflow">if</span> (some_condition())</div><div class="line">    {</div><div class="line">      <span class="comment">// ...</span></div><div class="line">      cv.signal();</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  mx.unlock(mx);</div><div class="line">  <span class="comment">// Do something else.</span></div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <code>pthread_cond_t</code> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p>Definition at line <a class="el" href="os-condvar_8h_source.html#l00122">122</a> of file <a class="el" href="os-condvar_8h_source.html">os-condvar.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a529d67d9f3d8b7dddba6ef37daec9ad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::Condition_variable::Condition_variable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a condition variable with default settings. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="section user"><dt>Errors</dt><dd>The constructor shall fail if:<ul>
<li><code>EAGAIN</code> - The system lacked the necessary resources (other than memory) to create the condition variable.</li>
<li><code>ENOMEM</code> - Insufficient memory exists to initialise the condition variable. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>The constructor shall not fail with an error code of <code>EINTR</code>.</dd></dl>
<p>This constructor shall initialise the condition variable object with default settings. The effect shall be equivalent to creating a condition variable object referring to the attributes in <code><a class="el" href="namespaceos_1_1rtos_1_1condvar.html#abcc9ce53c8bb1ce4a8274f11467cc6e2" title="Default condition variable initialiser. ">condvar::initializer</a></code>. Upon successful initialisation, the state of the condition variable object shall become initialised.</p>
<p>Only the condition variable object itself may be used for performing synchronisation. It is not allowed to make copies of condition variable objects.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines.</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_destroy.html"><code>pthread_cond_init()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p>Definition at line <a class="el" href="os-condvar_8cpp_source.html#l00234">234</a> of file <a class="el" href="os-condvar_8cpp_source.html">os-condvar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbee5659b170c813849cb3eb13c7d4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::Condition_variable::Condition_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1condvar_1_1_attributes.html">condvar::Attributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a condition variable with custom settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Reference to attributes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors</dt><dd>The constructor shall fail if:<ul>
<li><code>EAGAIN</code> - The system lacked the necessary resources (other than memory) to create the condition variable.</li>
<li><code>ENOMEM</code> - Insufficient memory exists to initialise the condition variable. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>The constructor shall not fail with an error code of <code>EINTR</code>.</dd></dl>
<p>This constructor shall initialise the condition variable object with attributes referenced by <em>attr</em>. If the attributes specified by <em>attr</em> are modified later, the condition variable attributes shall not be affected.</p>
<p>Upon successful initialisation, the state of the condition variable object shall become initialised.</p>
<p>Only the condition variable object itself may be used for performing synchronisation. It is not allowed to make copies of condition variable objects.</p>
<p>In cases where default condition variable attributes are appropriate, the variable <code><a class="el" href="namespaceos_1_1rtos_1_1condvar.html#abcc9ce53c8bb1ce4a8274f11467cc6e2" title="Default condition variable initialiser. ">condvar::initializer</a></code> can be used to initialise condition variables. The effect shall be equivalent to creating a condition variables object with the default constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines.</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_destroy.html"><code>pthread_cond_init()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p>Definition at line <a class="el" href="os-condvar_8cpp_source.html#l00268">268</a> of file <a class="el" href="os-condvar_8cpp_source.html">os-condvar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a955df145b56aa6b874f82c1fc1248bbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::Condition_variable::~Condition_variable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a condition variable. </p>
<p>This destructor shall destroy the condition variable object; the object becomes, in effect, uninitialised. An implementation may cause the destructor to set the object to an invalid value.</p>
<p>It shall be safe to destroy an initialised condition variable object upon which no threads are currently blocked. Attempting to destroy a condition variable object upon which other threads are currently blocked results in undefined behaviour.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines.</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_destroy.html"><code>pthread_cond_destroy()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p>Definition at line <a class="el" href="os-condvar_8cpp_source.html#l00298">298</a> of file <a class="el" href="os-condvar_8cpp_source.html">os-condvar.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab539df006aae5109e8a94e871d29fb0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::Condition_variable::broadcast </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify all threads waiting for a condition variable. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>All waiting threads signaled. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors</dt><dd>The function shall not fail with an error code of <code>EINTR</code>.</dd></dl>
<p>Unblock all threads currently blocked on the specified condition variable.</p>
<p>If more than one thread are blocked on a condition variable, the scheduling policy shall determine the order in which threads are unblocked.</p>
<p>When each thread unblocked as a result of a <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e" title="Notify all threads waiting for a condition variable. ">broadcast()</a></code> returns from its call to <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code>, the thread shall own the mutex with which it called <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code>. The thread(s) that are unblocked shall contend for the mutex according to the scheduling policy (if applicable), and as if each had called <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a525b1d221c3ecfac6ccfbb4cc4457c92" title="Lock the mutex. ">Mutex::lock()</a></code>.</p>
<p><code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e" title="Notify all threads waiting for a condition variable. ">broadcast()</a></code> may be called by a thread whether or not it currently owns the mutex that threads calling <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code> have associated with the condition variable during their waits; however, if predictable scheduling behaviour is required, then that mutex shall be locked by the thread calling <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e" title="Notify all threads waiting for a condition variable. ">broadcast()</a></code>.</p>
<p>The <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e" title="Notify all threads waiting for a condition variable. ">broadcast()</a></code> function shall have no effect if there are no threads currently blocked on this condition variable.</p>
<dl class="section user"><dt>Application usage</dt><dd>The <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e" title="Notify all threads waiting for a condition variable. ">broadcast()</a></code> function is used whenever the shared-variable state has been changed in a way that more than one thread can proceed with its task. Consider a single producer/multiple consumer problem, where the producer can insert multiple items on a list that is accessed one item at a time by the consumers. By calling the <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e" title="Notify all threads waiting for a condition variable. ">broadcast()</a></code> function, the producer would notify all consumers that might be waiting, and thereby the application would receive more throughput on a multi-processor. In addition, <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e" title="Notify all threads waiting for a condition variable. ">broadcast()</a></code> makes it easier to implement a read-write lock. The <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e" title="Notify all threads waiting for a condition variable. ">broadcast()</a></code> function is needed in order to wake up all waiting readers when a writer releases its lock. Finally, the two-phase commit algorithm can use this broadcast function to notify all clients of an impending transaction commit.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines.</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_broadcast.html"><code>pthread_cond_broadcast()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p>Definition at line <a class="el" href="os-condvar_8cpp_source.html#l00411">411</a> of file <a class="el" href="os-condvar_8cpp_source.html">os-condvar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ced578ffc847e14547b02ee1473c44e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * os::rtos::Named_object::name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get name. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A null terminated string.</dd></dl>
<p>All objects return a non-null string; anonymous objects return <code>"-"</code>. </p>

<p>Definition at line <a class="el" href="os-decls_8h_source.html#l01045">1045</a> of file <a class="el" href="os-decls_8h_source.html">os-decls.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2ec8f18bdeebd7e5cfa9246542258775"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool os::rtos::Condition_variable::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1_condition__variable.html">Condition_variable</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare condition variables. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The given condition variable is the same as this condition variable. </td></tr>
    <tr><td class="paramname">false</td><td>The condition variables are different.</td></tr>
  </table>
  </dd>
</dl>
<p>Identical condition variables should have the same memory address. </p>

<p>Definition at line <a class="el" href="os-condvar_8h_source.html#l00322">322</a> of file <a class="el" href="os-condvar_8h_source.html">os-condvar.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d473424e6a4d29b02bed96f471ff95a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::Condition_variable::signal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify one thread waiting for a condition variable. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The thread was signaled. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors</dt><dd>The function shall not fail with an error code of <code>EINTR</code>.</dd></dl>
<p>Unblock at least one of the threads that are blocked on the specified condition variable.</p>
<p>When each thread unblocked as a result of a <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a3d473424e6a4d29b02bed96f471ff95a" title="Notify one thread waiting for a condition variable. ">signal()</a></code> returns from its call to <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code>, the thread shall own the mutex with which it called <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code>. The thread(s) that are unblocked shall contend for the mutex according to the scheduling policy (if applicable), and as if each had called <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a525b1d221c3ecfac6ccfbb4cc4457c92" title="Lock the mutex. ">Mutex::lock()</a></code>.</p>
<p><code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a3d473424e6a4d29b02bed96f471ff95a" title="Notify one thread waiting for a condition variable. ">signal()</a></code> may be called by a thread whether or not it currently owns the mutex that threads calling <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code> have associated with the condition variable during their waits; however, if predictable scheduling behaviour is required, then that mutex shall be locked by the thread calling <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a3d473424e6a4d29b02bed96f471ff95a" title="Notify one thread waiting for a condition variable. ">signal()</a></code>.</p>
<p>The <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a3d473424e6a4d29b02bed96f471ff95a" title="Notify one thread waiting for a condition variable. ">signal()</a></code> function shall have no effect if there are no threads currently blocked on this condition variable.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines.</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_signal.html"><code>pthread_cond_signal()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p>Definition at line <a class="el" href="os-condvar_8cpp_source.html#l00342">342</a> of file <a class="el" href="os-condvar_8cpp_source.html">os-condvar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7ce637cd4aaee2e34d72ee8f1d5f16f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::Condition_variable::timed_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1_mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceos_1_1rtos_1_1clock.html#a61ab6fb2482ab2d9ef03f6e0aa445287">clock::duration_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed wait for a condition variable to be notified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Reference to the associated mutex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The condition change was signaled. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines, or the mutex type is <code>mutex::type::errorcheck</code> or the mutex is a robust mutex, and the current thread does not own the mutex. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The state protected by the mutex is not recoverable. </td></tr>
    <tr><td class="paramname">EOWNERDEAD</td><td>The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent. </td></tr>
    <tr><td class="paramname">ETIMEDOUT</td><td>The timeout has passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors</dt><dd>The function shall not fail with an error code of <code>EINTR</code>.</dd></dl>
<p>Block on a condition variable. The application shall ensure that this function is called with <em>mutex</em> locked by the calling thread; otherwise, an error (for <code>mutex::type::errorcheck</code> and robust mutexes) or undefined behaviour (for other mutexes) results.</p>
<p>These functions atomically release <em>mutex</em> and cause the calling thread to block on the condition variable cond; atomically here means "atomically with respect to access
by another thread to the mutex and then the condition variable". That is, if another thread is able to acquire the mutex after the about-to-block thread has released it, then a subsequent call to <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e" title="Notify all threads waiting for a condition variable. ">broadcast()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a3d473424e6a4d29b02bed96f471ff95a" title="Notify one thread waiting for a condition variable. ">signal()</a></code> in that thread shall behave as if it were issued after the about-to-block thread has blocked.</p>
<p>Upon successful return, the mutex shall have been locked and shall be owned by the calling thread. If <em>mutex</em> is a robust mutex where an owner terminated while holding the lock and the state is recoverable, the mutex shall be acquired even though the function returns an error code.</p>
<p>When using condition variables there is always a Boolean predicate involving shared variables associated with each condition wait that is true if the thread should proceed. Spurious wakeups from the <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code> functions may occur. Since the return from <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code> does not imply anything about the value of this predicate, the predicate should be re-evaluated upon such return.</p>
<p>When a thread waits on a condition variable, having specified a particular mutex to either the <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code> operation, a dynamic binding is formed between that mutex and condition variable that remains in effect as long as at least one thread is blocked on the condition variable. During this time, the effect of an attempt by any thread to wait on that condition variable using a different mutex is undefined. Once all waiting threads have been unblocked (as by the <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e" title="Notify all threads waiting for a condition variable. ">broadcast()</a></code> operation), the next wait operation on that condition variable shall form a new dynamic binding with the mutex specified by that wait operation. Even though the dynamic binding between condition variable and <em>mutex</em> may be removed or replaced between the time a thread is unblocked from a wait on the condition variable and the time that it returns to the caller or begins cancellation cleanup, the unblocked thread shall always re-acquire the mutex specified in the condition wait operation call from which it is returning.</p>
<p>A condition wait (whether timed or not) is a cancellation point. When the cancellability type of a thread is set to PTHREAD_CANCEL_DEFERRED, a side-effect of acting upon a cancellation request while in a condition wait is that the mutex is (in effect) re-acquired before calling the first cancellation cleanup handler. The effect is as if the thread were unblocked, allowed to execute up to the point of returning from the call to <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code>, but at that point notices the cancellation request and instead of returning to the caller of <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code>, starts the thread cancellation activities, which includes calling cancellation cleanup handlers.</p>
<p>A thread that has been unblocked because it has been cancelled while blocked in a call to <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code> shall not consume any condition signal that may be directed concurrently at the condition variable if there are other threads blocked on the condition variable.</p>
<p>The <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code> function shall be equivalent to <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code>, except that an error is returned if the timeout specified by <em>timeout</em> passes (that is, system time equals or exceeds now() + timeout) before the condition cond is signalled or broadcasted. When such timeouts occur, <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code> shall nonetheless release and re-acquire the mutex referenced by <em>mutex</em>, and may consume a condition signal directed concurrently at the condition variable.</p>
<p>The condition variable shall have a clock attribute which specifies the clock that shall be used to measure the time specified by the <em>ticks</em> argument. The <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#aa7ce637cd4aaee2e34d72ee8f1d5f16f" title="Timed wait for a condition variable to be notified. ">timed_wait()</a></code> function is also a cancellation point. The resolution of the timeout shall be the resolution of the clock on which it is based (by default the SysTick clock for CMSIS).</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines.</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html"><code>pthread_cond_timedwait()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p>Definition at line <a class="el" href="os-condvar_8cpp_source.html#l00649">649</a> of file <a class="el" href="os-condvar_8cpp_source.html">os-condvar.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7fb95476af3012f02b138dbcd5931214"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::Condition_variable::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1_mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a condition variable to be notified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Reference to the associated mutex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The condition change was signaled. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines, or the mutex type is <code>mutex::type::errorcheck</code> or the mutex is a robust mutex, and the current thread does not own the mutex. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The state protected by the mutex is not recoverable. </td></tr>
    <tr><td class="paramname">EOWNERDEAD</td><td>The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors</dt><dd>The function shall not fail with an error code of <code>EINTR</code>.</dd></dl>
<p>Block on a condition variable. The application shall ensure that this function is called with <em>mutex</em> locked by the calling thread; otherwise, an error (for <code>mutex::type::errorcheck</code> and robust mutexes) or undefined behaviour (for other mutexes) results.</p>
<p>These functions atomically release <em>mutex</em> and cause the calling thread to block on the condition variable; atomically here means "atomically with respect to access
by another thread to the mutex and then the condition variable". That is, if another thread is able to acquire the mutex after the about-to-block thread has released it, then a subsequent call to <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e" title="Notify all threads waiting for a condition variable. ">broadcast()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a3d473424e6a4d29b02bed96f471ff95a" title="Notify one thread waiting for a condition variable. ">signal()</a></code> in that thread shall behave as if it were issued after the about-to-block thread has blocked.</p>
<p>Upon successful return, the mutex shall have been locked and shall be owned by the calling thread. If <em>mutex</em> is a robust mutex where an owner terminated while holding the lock and the state is recoverable, the mutex shall be acquired even though the function returns an error code.</p>
<p>When using condition variables there is always a Boolean predicate involving shared variables associated with each condition wait that is true if the thread should proceed. Spurious wakeups from the <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code> functions may occur. Since the return from <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code> does not imply anything about the value of this predicate, the predicate should be re-evaluated upon such return.</p>
<p>When a thread waits on a condition variable, having specified a particular mutex to either the the <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code> operation, a dynamic binding is formed between that mutex and condition variable that remains in effect as long as at least one thread is blocked on the condition variable. During this time, the effect of an attempt by any thread to wait on that condition variable using a different mutex is undefined. Once all waiting threads have been unblocked (as by the <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#ab539df006aae5109e8a94e871d29fb0e" title="Notify all threads waiting for a condition variable. ">broadcast()</a></code> operation), the next wait operation on that condition variable shall form a new dynamic binding with the mutex specified by that wait operation. Even though the dynamic binding between condition variable and <em>mutex</em> may be removed or replaced between the time a thread is unblocked from a wait on the condition variable and the time that it returns to the caller or begins cancellation cleanup, the unblocked thread shall always re-acquire the mutex specified in the condition wait operation call from which it is returning.</p>
<p>A condition wait (whether timed or not) is a cancellation point. When the cancellability type of a thread is set to PTHREAD_CANCEL_DEFERRED, a side-effect of acting upon a cancellation request while in a condition wait is that the mutex is (in effect) re-acquired before calling the first cancellation cleanup handler. The effect is as if the thread were unblocked, allowed to execute up to the point of returning from the call to <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code>, but at that point notices the cancellation request and instead of returning to the caller of <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code>, starts the thread cancellation activities, which includes calling cancellation cleanup handlers.</p>
<p>A thread that has been unblocked because it has been cancelled while blocked in a call to <code><a class="el" href="classos_1_1rtos_1_1_condition__variable.html#a7fb95476af3012f02b138dbcd5931214" title="Wait for a condition variable to be notified. ">wait()</a></code> shall not consume any condition signal that may be directed concurrently at the condition variable if there are other threads blocked on the condition variable.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines.</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_wait.html"><code>pthread_cond_wait()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p>Definition at line <a class="el" href="os-condvar_8cpp_source.html#l00507">507</a> of file <a class="el" href="os-condvar_8cpp_source.html">os-condvar.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa5d2137667e086514699c240abf2772a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classos_1_1rtos_1_1_waiting__threads__list.html">Waiting_threads_list</a> os::rtos::Condition_variable::list_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="os-condvar_8h_source.html#l00284">284</a> of file <a class="el" href="os-condvar_8h_source.html">os-condvar.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad7667db8bf3171d900237500cb0e1e67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char *const os::rtos::Named_object::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to name. </p>
<p>To save space, the null terminated string passed to the constructor is not copied locally. Instead, the pointer to the string is copied, so the caller must ensure that the pointer life cycle is at least as long as the object life cycle. A constant string (stored in flash) is preferred. </p>

<p>Definition at line <a class="el" href="os-decls_8h_source.html#l00873">873</a> of file <a class="el" href="os-decls_8h_source.html">os-decls.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/cmsis-plus/rtos/<a class="el" href="os-condvar_8h_source.html">os-condvar.h</a></li>
<li>src/cmsis-plus/rtos/<a class="el" href="os-condvar_8cpp_source.html">os-condvar.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceos.html">os</a></li><li class="navelem"><a class="el" href="namespaceos_1_1rtos.html">rtos</a></li><li class="navelem"><a class="el" href="classos_1_1rtos_1_1_condition__variable.html">Condition_variable</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
