<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CMSIS++ Reference: os::rtos::Mutex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-16767008-14', 'auto');
  ga('send', 'pageview');
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="$relpath/../../../.."><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign">
   <div>
     <div id="projectname">CMSIS++ Reference
     &#160;<span id="projectnumber">0.1.1</span>
     </div>
     <div id="projectmotto" class="float:right;">“Perfekt ist nicht gut genug”</div>
     </div>  
   </div>
   <div id="projectbrief">CMSIS++: A proposal for the next generation CMSIS, written in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classos_1_1rtos_1_1_mutex.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classos_1_1rtos_1_1_mutex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">os::rtos::Mutex Class Reference<div class="ingroups"><a class="el" href="group__cmsis-plus-rtos.html">CMSIS++ RTOS API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>POSIX compliant <b>mutex</b>.  
 <a href="classos_1_1rtos_1_1_mutex.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="os_8h_source.html">cmsis-plus/rtos/os.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="classos_1_1rtos_1_1_named__object.html">os::rtos::Named_object</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors &amp; Destructor</div></td></tr>
<tr class="memitem:ad8dd37e9132a372809f3548868645e41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#ad8dd37e9132a372809f3548868645e41">Mutex</a> ()</td></tr>
<tr class="memdesc:ad8dd37e9132a372809f3548868645e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mutex with default settings.  <a href="#ad8dd37e9132a372809f3548868645e41">More...</a><br /></td></tr>
<tr class="separator:ad8dd37e9132a372809f3548868645e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0fd06460ecc869e747936b347a6d62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a2c0fd06460ecc869e747936b347a6d62">Mutex</a> (const <a class="el" href="classos_1_1rtos_1_1mutex_1_1_attributes.html">mutex::Attributes</a> &amp;attr)</td></tr>
<tr class="memdesc:a2c0fd06460ecc869e747936b347a6d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mutex with custom settings.  <a href="#a2c0fd06460ecc869e747936b347a6d62">More...</a><br /></td></tr>
<tr class="separator:a2c0fd06460ecc869e747936b347a6d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a18d00cf61df606519eefb88fd34290"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a9a18d00cf61df606519eefb88fd34290">~Mutex</a> ()</td></tr>
<tr class="memdesc:a9a18d00cf61df606519eefb88fd34290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the mutex.  <a href="#a9a18d00cf61df606519eefb88fd34290">More...</a><br /></td></tr>
<tr class="separator:a9a18d00cf61df606519eefb88fd34290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:ad10731d069e6c43ede9d5de8d4b64f9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#ad10731d069e6c43ede9d5de8d4b64f9e">operator==</a> (const <a class="el" href="classos_1_1rtos_1_1_mutex.html">Mutex</a> &amp;rhs) const </td></tr>
<tr class="memdesc:ad10731d069e6c43ede9d5de8d4b64f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare mutexes.  <a href="#ad10731d069e6c43ede9d5de8d4b64f9e">More...</a><br /></td></tr>
<tr class="separator:ad10731d069e6c43ede9d5de8d4b64f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a525b1d221c3ecfac6ccfbb4cc4457c92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a525b1d221c3ecfac6ccfbb4cc4457c92">lock</a> (void)</td></tr>
<tr class="memdesc:a525b1d221c3ecfac6ccfbb4cc4457c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the mutex.  <a href="#a525b1d221c3ecfac6ccfbb4cc4457c92">More...</a><br /></td></tr>
<tr class="separator:a525b1d221c3ecfac6ccfbb4cc4457c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ca0fafa0ca551bdabe8ca91132df77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#ac2ca0fafa0ca551bdabe8ca91132df77">try_lock</a> (void)</td></tr>
<tr class="memdesc:ac2ca0fafa0ca551bdabe8ca91132df77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the mutex.  <a href="#ac2ca0fafa0ca551bdabe8ca91132df77">More...</a><br /></td></tr>
<tr class="separator:ac2ca0fafa0ca551bdabe8ca91132df77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1d10a9a21aac45d959afe028a439ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a7b1d10a9a21aac45d959afe028a439ea">timed_lock</a> (<a class="el" href="namespaceos_1_1rtos_1_1clock.html#a61ab6fb2482ab2d9ef03f6e0aa445287">clock::duration_t</a> timeout)</td></tr>
<tr class="memdesc:a7b1d10a9a21aac45d959afe028a439ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed attempt to lock the mutex.  <a href="#a7b1d10a9a21aac45d959afe028a439ea">More...</a><br /></td></tr>
<tr class="separator:a7b1d10a9a21aac45d959afe028a439ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746365b2ec3520b0795fce1d40937d29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a746365b2ec3520b0795fce1d40937d29">unlock</a> (void)</td></tr>
<tr class="memdesc:a746365b2ec3520b0795fce1d40937d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the mutex.  <a href="#a746365b2ec3520b0795fce1d40937d29">More...</a><br /></td></tr>
<tr class="separator:a746365b2ec3520b0795fce1d40937d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d43f0dac308800a0d069f6b526b920b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cmsis-plus-rtos.html#ga1257cd2ea834219f38831bcf66485103">thread::priority_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a6d43f0dac308800a0d069f6b526b920b">prio_ceiling</a> (void) const </td></tr>
<tr class="memdesc:a6d43f0dac308800a0d069f6b526b920b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the priority ceiling of a mutex.  <a href="#a6d43f0dac308800a0d069f6b526b920b">More...</a><br /></td></tr>
<tr class="separator:a6d43f0dac308800a0d069f6b526b920b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1121d41ad4ed96b3ca15dbec654ebc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#ad1121d41ad4ed96b3ca15dbec654ebc0">prio_ceiling</a> (<a class="el" href="group__cmsis-plus-rtos.html#ga1257cd2ea834219f38831bcf66485103">thread::priority_t</a> prio_ceiling, <a class="el" href="group__cmsis-plus-rtos.html#ga1257cd2ea834219f38831bcf66485103">thread::priority_t</a> *old_prio_ceiling=nullptr)</td></tr>
<tr class="memdesc:ad1121d41ad4ed96b3ca15dbec654ebc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the priority ceiling of a mutex.  <a href="#ad1121d41ad4ed96b3ca15dbec654ebc0">More...</a><br /></td></tr>
<tr class="separator:ad1121d41ad4ed96b3ca15dbec654ebc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785a59060ced71a2696168cc2a6e6dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a785a59060ced71a2696168cc2a6e6dca">consistent</a> (void)</td></tr>
<tr class="memdesc:a785a59060ced71a2696168cc2a6e6dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark mutex as consistent.  <a href="#a785a59060ced71a2696168cc2a6e6dca">More...</a><br /></td></tr>
<tr class="separator:a785a59060ced71a2696168cc2a6e6dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb1d517027d6b62b725e2fc99fc8c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classos_1_1rtos_1_1_thread.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a3cb1d517027d6b62b725e2fc99fc8c1b">owner</a> (void)</td></tr>
<tr class="memdesc:a3cb1d517027d6b62b725e2fc99fc8c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread that owns the mutex.  <a href="#a3cb1d517027d6b62b725e2fc99fc8c1b">More...</a><br /></td></tr>
<tr class="separator:a3cb1d517027d6b62b725e2fc99fc8c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9f58eb57bb73a20a8ecef6560c9ca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a0c9f58eb57bb73a20a8ecef6560c9ca5">reset</a> (void)</td></tr>
<tr class="memdesc:a0c9f58eb57bb73a20a8ecef6560c9ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the mutex.  <a href="#a0c9f58eb57bb73a20a8ecef6560c9ca5">More...</a><br /></td></tr>
<tr class="separator:a0c9f58eb57bb73a20a8ecef6560c9ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a1ced578ffc847e14547b02ee1473c44e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_named__object.html#a1ced578ffc847e14547b02ee1473c44e">name</a> (void) const </td></tr>
<tr class="memdesc:a1ced578ffc847e14547b02ee1473c44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name.  <a href="#a1ced578ffc847e14547b02ee1473c44e">More...</a><br /></td></tr>
<tr class="separator:a1ced578ffc847e14547b02ee1473c44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Member Functions</div></td></tr>
<tr class="memitem:a2ea700789c27d2263933e41512172047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a2ea700789c27d2263933e41512172047">_init</a> (void)</td></tr>
<tr class="memdesc:a2ea700789c27d2263933e41512172047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal initialisation.  <a href="#a2ea700789c27d2263933e41512172047">More...</a><br /></td></tr>
<tr class="separator:a2ea700789c27d2263933e41512172047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc1b2d6b18f353d1738ec3e0d66ed5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a0dc1b2d6b18f353d1738ec3e0d66ed5b">_try_lock</a> (<a class="el" href="classos_1_1rtos_1_1_thread.html">Thread</a> *crt_thread)</td></tr>
<tr class="memdesc:a0dc1b2d6b18f353d1738ec3e0d66ed5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function used to lock the mutex.  <a href="#a0dc1b2d6b18f353d1738ec3e0d66ed5b">More...</a><br /></td></tr>
<tr class="separator:a0dc1b2d6b18f353d1738ec3e0d66ed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Member Variables</div></td></tr>
<tr class="memitem:a974b7004fe2325cb1560fb7a3301ae5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classos_1_1rtos_1_1_thread.html">Thread</a> *volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a974b7004fe2325cb1560fb7a3301ae5c">owner_</a></td></tr>
<tr class="separator:a974b7004fe2325cb1560fb7a3301ae5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b28039841287b714aee8c8400663334"><td class="memItemLeft" align="right" valign="top">port::Waiting_threads_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a7b28039841287b714aee8c8400663334">list_</a></td></tr>
<tr class="separator:a7b28039841287b714aee8c8400663334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cd88a36e581a1f273affcae7ab4b40"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="namespaceos_1_1rtos_1_1mutex.html#a301d03a8d9644b148d90ddb328c91172">mutex::count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a76cd88a36e581a1f273affcae7ab4b40">count_</a></td></tr>
<tr class="separator:a76cd88a36e581a1f273affcae7ab4b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3887353afd8a7cfa4190996b49ad3a6"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="group__cmsis-plus-rtos.html#ga1257cd2ea834219f38831bcf66485103">thread::priority_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#aa3887353afd8a7cfa4190996b49ad3a6">prio_ceiling_</a></td></tr>
<tr class="separator:aa3887353afd8a7cfa4190996b49ad3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a04175eec6fe100b4255355490dfc3"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="group__cmsis-plus-rtos.html#ga1257cd2ea834219f38831bcf66485103">thread::priority_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a45a04175eec6fe100b4255355490dfc3">owner_prio_</a></td></tr>
<tr class="separator:a45a04175eec6fe100b4255355490dfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a88571e9bfcb1b5551b6f0082a6fa6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceos_1_1rtos_1_1mutex.html#a3e2a870f9540d3ea14bfcf895bfe611a">mutex::type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a84a88571e9bfcb1b5551b6f0082a6fa6">type_</a></td></tr>
<tr class="separator:a84a88571e9bfcb1b5551b6f0082a6fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671575343eaa2fbaab379756663f19f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceos_1_1rtos_1_1mutex.html#aafe5223e5997cc46df1ab8e0fd7c1aa9">mutex::protocol_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#a671575343eaa2fbaab379756663f19f0">protocol_</a></td></tr>
<tr class="separator:a671575343eaa2fbaab379756663f19f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f33f759c85dffe5b68672fc3f67277"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceos_1_1rtos_1_1mutex.html#aba4f58e0f8e0be35108d2bcd87eb8866">mutex::robustness_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#ad3f33f759c85dffe5b68672fc3f67277">robustness_</a></td></tr>
<tr class="separator:ad3f33f759c85dffe5b68672fc3f67277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba293f0645e775f3750ab7116f17b163"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceos_1_1rtos_1_1mutex.html#a301d03a8d9644b148d90ddb328c91172">mutex::count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_mutex.html#aba293f0645e775f3750ab7116f17b163">max_count_</a></td></tr>
<tr class="separator:aba293f0645e775f3750ab7116f17b163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Member Variables</div></td></tr>
<tr class="memitem:ad7667db8bf3171d900237500cb0e1e67"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1_named__object.html#ad7667db8bf3171d900237500cb0e1e67">name_</a></td></tr>
<tr class="memdesc:ad7667db8bf3171d900237500cb0e1e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to name.  <a href="#ad7667db8bf3171d900237500cb0e1e67">More...</a><br /></td></tr>
<tr class="separator:ad7667db8bf3171d900237500cb0e1e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>POSIX compliant <b>mutex</b>. </p>
<p>A synchronisation object used to allow multiple threads to serialise their access to shared data. The name derives from the capability it provides; namely, <b>mutual-exclusion</b>. The thread that has locked a mutex becomes its owner and remains the owner until that same thread unlocks the mutex.</p>
<dl class="section user"><dt>Tradeoff Between Error Checks and Performance Supported</dt><dd></dd></dl>
<p>Many error conditions that can occur are not required to be detected by the implementation in order to let implementations trade off performance versus degree of error checking according to the needs of their specific applications and execution environment. As a general rule, conditions caused by the system (such as insufficient memory) are required to be detected, but conditions caused by an erroneously coded application (such as failing to provide adequate synchronisation to prevent a mutex from being deleted while in use) are specified to result in undefined behaviour.</p>
<p>A wide range of implementations is thus made possible. For example, an implementation intended for application debugging may implement all of the error checks, but an implementation running a single, provably correct application under very tight performance constraints in an embedded computer might implement minimal checks. An implementation might even be provided in two versions, similar to the options that compilers provide: a full-checking, but slower version; and a limited-checking, but faster version. To forbid this optionality would be a disservice to users.</p>
<p>By carefully limiting the use of "undefined behaviour" only to things that an erroneous (badly coded) application might do, and by defining that resource-not-available errors are mandatory, POSIX ensures that a fully-conforming application is portable across the full range of implementations, while not forcing all implementations to add overhead to check for numerous things that a correct program never does. When the behaviour is undefined, no error number is specified to be returned on implementations that do detect the condition. This is because undefined behaviour means anything can happen, which includes returning with any value (which might happen to be a valid, but different, error number). However, since the error number might be useful to application developers when diagnosing problems during application development, a recommendation is made in rationale that implementors should return a particular error number if their implementation does detect the condition.</p>
<dl class="section user"><dt>Static Initialisers</dt><dd></dd></dl>
<p>Providing for static initialisation of statically allocated synchronisation objects allows modules with private static synchronisation variables to avoid runtime initialisation tests and overhead. Furthermore, it simplifies the coding of self-initialising modules. Such modules are common in C libraries, where for various reasons the design calls for self-initialisation instead of requiring an explicit module initialisation function to be called. An example use of static initialisation:</p>
<div class="fragment"><div class="line"><span class="comment">// Create a normal mutex. Same as using the default constructor.</span></div><div class="line"><a class="code" href="classos_1_1rtos_1_1_mutex.html#ad8dd37e9132a372809f3548868645e41">Mutex</a> mx { <a class="code" href="namespaceos_1_1rtos_1_1mutex.html#a8f98fec4c3f9b170459aaabd975de69e">normal_initializer</a> };</div><div class="line"></div><div class="line"><span class="comment">// Create a recursive mutex.</span></div><div class="line"><a class="code" href="classos_1_1rtos_1_1_mutex.html#ad8dd37e9132a372809f3548868645e41">Mutex</a> rmx { <a class="code" href="namespaceos_1_1rtos_1_1mutex.html#a993b1031f91e1417f95c473a68078588">recursive_initializer</a> };</div></div><!-- fragment --><dl class="section user"><dt>Example</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Protected resource.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">  <span class="keywordtype">int</span> count;</div><div class="line">} res_t;</div><div class="line"></div><div class="line">res_t res;</div><div class="line"></div><div class="line"><span class="comment">// Mutex to protect the resource.</span></div><div class="line"><a class="code" href="classos_1_1rtos_1_1_mutex.html#ad8dd37e9132a372809f3548868645e41">Mutex</a> mx;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">func(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// Do something</span></div><div class="line"></div><div class="line">  mx.lock();</div><div class="line">  res.count++;</div><div class="line">  mx.unlock();</div><div class="line"></div><div class="line">  <span class="comment">// Do something else.</span></div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <code>pthread_mutex_t</code> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p>Definition at line <a class="el" href="os_8h_source.html#l02505">2505</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad8dd37e9132a372809f3548868645e41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::Mutex::Mutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mutex with default settings. </p>
<dl class="section user"><dt>Parameters</dt><dd>None</dd></dl>
<p>This constructor shall initialise the mutex object with default settings. The effect shall be equivalent to creating a mutex object referring to the attributes in <code><a class="el" href="namespaceos_1_1rtos_1_1mutex.html#a8f98fec4c3f9b170459aaabd975de69e" title="Default normal mutex initialiser. ">mutex::normal_initializer</a></code>. Upon successful initialisation, the state of the mutex object shall become initialised, unlocked.</p>
<p>Only the mutex object itself may be used for performing synchronisation. It is not allowed to make copies of mutex objects.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html"><code>pthread_mutex_init()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00364">364</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c0fd06460ecc869e747936b347a6d62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::Mutex::Mutex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1mutex_1_1_attributes.html">mutex::Attributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mutex with custom settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Reference to attributes.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor shall initialise the mutex object with attributes referenced by <em>attr</em>. If the attributes specified by <em>attr</em> are modified later, the mutex attributes shall not be affected. Upon successful initialisation, the state of the mutex object shall become initialised.</p>
<p>Only the mutex object itself may be used for performing synchronisation. It is not allowed to make copies of condition variable objects.</p>
<p>In cases where default mutex attributes are appropriate, the variables <code><a class="el" href="namespaceos_1_1rtos_1_1mutex.html#a8f98fec4c3f9b170459aaabd975de69e" title="Default normal mutex initialiser. ">mutex::normal_initializer</a></code> or <code><a class="el" href="namespaceos_1_1rtos_1_1mutex.html#a993b1031f91e1417f95c473a68078588" title="Default recursive mutex initialiser. ">mutex::recursive_initializer</a></code> can be used to initialise mutex objects. The effect shall be equivalent to creating a mutex object with the default constructor.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html"><code>pthread_mutex_init()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00398">398</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a18d00cf61df606519eefb88fd34290"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::Mutex::~Mutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the mutex. </p>
<p>This destructor shall destroy the mutex object; the object becomes, in effect, uninitialised. An implementation may cause the destructor to set the object to an invalid value.</p>
<p>It shall be safe to destroy an initialised mutex that is unlocked. Attempting to destroy a locked mutex or a mutex that is referenced (for example, while being used in a <code>timed_wait()</code> or <code>wait()</code>) by another thread results in undefined behaviour.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_destroy.html"><code>pthread_mutex_destroy()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00448">448</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2ea700789c27d2263933e41512172047"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::Mutex::_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal initialisation. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00465">465</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0dc1b2d6b18f353d1738ec3e0d66ed5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::Mutex::_try_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1_thread.html">Thread</a> *&#160;</td>
          <td class="paramname"><em>crt_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function used to lock the mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The mutex was locked. </td></tr>
    <tr><td class="paramname">false</td><td>The mutex was not locked. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00480">480</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a785a59060ced71a2696168cc2a6e6dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::Mutex::consistent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark mutex as consistent. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The mutex was marked as consistent. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The mutex object referenced by mutex is not robust or does not protect an inconsistent state.</td></tr>
  </table>
  </dd>
</dl>
<p>If the robust mutex is in an inconsistent state, the <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a785a59060ced71a2696168cc2a6e6dca" title="Mark mutex as consistent. ">consistent()</a></code> function can be used to mark the state protected by the mutex referenced by mutex as consistent again.</p>
<p>If an owner of a robust mutex terminates while holding the mutex, the mutex becomes inconsistent and the next thread that acquires the mutex lock shall be notified of the state by the return value <code>EOWNERDEAD</code>. In this case, the mutex does not become normally usable again until the state is marked consistent.</p>
<p>If the thread which acquired the mutex lock with the return value <code>EOWNERDEAD</code> terminates before calling either <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a785a59060ced71a2696168cc2a6e6dca" title="Mark mutex as consistent. ">consistent()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a746365b2ec3520b0795fce1d40937d29" title="Unlock the mutex. ">unlock()</a></code>, the next thread that acquires the mutex lock shall be notified about the state of the mutex by the return value <code>EOWNERDEAD</code>.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_consistent.html"><code>pthread_mutex_consistent()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00984">984</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a525b1d221c3ecfac6ccfbb4cc4457c92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::Mutex::lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The mutex was locked. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The state protected by the mutex is not recoverable.. </td></tr>
    <tr><td class="paramname">EAGAIN</td><td>The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The mutex was created with the protocol attribute having the value PTHREAD_PRIO_PROTECT and the calling thread's priority is higher than the mutex's current priority ceiling. </td></tr>
    <tr><td class="paramname">EOWNERDEAD</td><td>The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent. </td></tr>
    <tr><td class="paramname">EDEADLK</td><td>The mutex type is <code>mutex::type::errorcheck</code> and the current thread already owns the mutex.</td></tr>
  </table>
  </dd>
</dl>
<p>If the mutex is free, lock it. If the mutex is already locked by another thread, the calling thread shall block until the mutex becomes available. This operation shall return with the mutex object referenced by mutex in the locked state with the calling thread as its owner. If a thread attempts to relock a mutex that it has already locked, <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a525b1d221c3ecfac6ccfbb4cc4457c92" title="Lock the mutex. ">lock()</a></code> shall behave as described in the <b>Relock</b> column of the following table. If a thread attempts to unlock a mutex that it has not locked or a mutex which is unlocked, <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a746365b2ec3520b0795fce1d40937d29" title="Unlock the mutex. ">unlock()</a></code> shall behave as described in the <b>Unlock When Not Owner</b> column of the following table.</p>
<table class="doxtable">
<tr>
<th>Mutex Type </th><th>Robustness </th><th>Relock </th><th>Unlock When Not Owner  </th></tr>
<tr>
<td>normal </td><td>non-robust </td><td>deadlock </td><td>undefined behaviour </td></tr>
<tr>
<td>normal </td><td>robust </td><td>deadlock </td><td>error </td></tr>
<tr>
<td>errorcheck </td><td>either </td><td>error </td><td>error </td></tr>
<tr>
<td>recursive </td><td>either </td><td>recursive </td><td>error </td></tr>
<tr>
<td>default </td><td>non-robust </td><td>undefined </td><td>undefined behaviour </td></tr>
<tr>
<td>default </td><td>robust </td><td>undefined </td><td>error </td></tr>
</table>
<p>Where the table indicates recursive behaviour, the mutex shall maintain the concept of a lock count. When a thread successfully acquires a mutex for the first time, the lock count shall be set to one. Every time a thread relocks this mutex, the lock count shall be incremented by one. Each time the thread unlocks the mutex, the lock count shall be decremented by one. When the lock count reaches zero, the mutex shall become available for other threads to acquire.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html"><code>pthread_mutex_lock()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00594">594</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ced578ffc847e14547b02ee1473c44e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * os::rtos::Named_object::name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get name. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A null terminated string.</dd></dl>
<p>All objects return a non-null string; anonymous objects return <code>"-"</code>. </p>

<p>Definition at line <a class="el" href="os_8h_source.html#l04686">4686</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad10731d069e6c43ede9d5de8d4b64f9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool os::rtos::Mutex::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1_mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare mutexes. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The given mutex is the same as this mutex. </td></tr>
    <tr><td class="paramname">false</td><td>The mutexes are different.</td></tr>
  </table>
  </dd>
</dl>
<p>Identical mutexes should have the same memory address. </p>

<p>Definition at line <a class="el" href="os_8h_source.html#l04944">4944</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3cb1d517027d6b62b725e2fc99fc8c1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classos_1_1rtos_1_1_thread.html">Thread</a> * os::rtos::Mutex::owner </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the thread that owns the mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to thread or <code>nullptr</code> if not owned. </dd></dl>

<p>Definition at line <a class="el" href="os_8h_source.html#l04950">4950</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6d43f0dac308800a0d069f6b526b920b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cmsis-plus-rtos.html#ga1257cd2ea834219f38831bcf66485103">thread::priority_t</a> os::rtos::Mutex::prio_ceiling </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the priority ceiling of a mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The priority ceiling.</dd></dl>
<p>Return the current priority ceiling of the mutex.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_getprioceiling.html"><code>pthread_mutex_getprioceiling()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00882">882</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad1121d41ad4ed96b3ca15dbec654ebc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::Mutex::prio_ceiling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cmsis-plus-rtos.html#ga1257cd2ea834219f38831bcf66485103">thread::priority_t</a>&#160;</td>
          <td class="paramname"><em>prio_ceiling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cmsis-plus-rtos.html#ga1257cd2ea834219f38831bcf66485103">thread::priority_t</a> *&#160;</td>
          <td class="paramname"><em>old_prio_ceiling</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the priority ceiling of a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prio_ceiling</td><td>new priority. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">old_prio_ceiling</td><td>pointer to location where to store the previous priority; may be <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The priority was changed. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to lock the mutex as if by a call to <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a525b1d221c3ecfac6ccfbb4cc4457c92" title="Lock the mutex. ">lock()</a></code>, except that the process of locking the mutex need not adhere to the priority protect protocol. On acquiring the mutex it shall change the mutex's priority ceiling and then release the mutex as if by a call to <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a746365b2ec3520b0795fce1d40937d29" title="Unlock the mutex. ">unlock()</a></code>. When the change is successful, the previous value of the priority ceiling shall be returned in old_ceiling.</p>
<p>If <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a6d43f0dac308800a0d069f6b526b920b" title="Get the priority ceiling of a mutex. ">prio_ceiling()</a></code> function fails, the mutex priority ceiling shall not be changed.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_setprioceiling.html"><code>pthread_mutex_setprioceiling()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00920">920</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c9f58eb57bb73a20a8ecef6560c9ca5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::Mutex::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The mutex was reset.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the mutex to initial unlocked state. If there were threads waiting for this mutex, wakeup all, then clear the waiting list.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Extension to standard, no POSIX similar functionality identified. </dd></dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l01011">1011</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b1d10a9a21aac45d959afe028a439ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::Mutex::timed_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceos_1_1rtos_1_1clock.html#a61ab6fb2482ab2d9ef03f6e0aa445287">clock::duration_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed attempt to lock the mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout to wait, in clock units (ticks or seconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The mutex was locked. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">ETIMEDOUT</td><td>The mutex could not be locked before the specified timeout expired. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The state protected by the mutex is not recoverable. </td></tr>
    <tr><td class="paramname">EAGAIN</td><td>The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded. </td></tr>
    <tr><td class="paramname">EDEADLK</td><td>The mutex type is <code>mutex::type::errorcheck</code> and the current thread already owns the mutex. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The process or thread would have blocked, and the abstime parameter specified a nanoseconds field value less than zero or greater than or equal to 1000 million. </td></tr>
    <tr><td class="paramname">EOWNERDEAD</td><td>The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent.</td></tr>
  </table>
  </dd>
</dl>
<p>Try to lock the mutex object referenced by mutex. If the mutex is already locked, the calling thread shall block until the mutex becomes available as in the <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a525b1d221c3ecfac6ccfbb4cc4457c92" title="Lock the mutex. ">lock()</a></code> function. If the mutex cannot be locked without waiting for another thread to unlock the mutex, this wait shall be terminated when the specified timeout expires.</p>
<p>The timeout shall expire after the number of time units (that is when the value of that clock equals or exceeds (now()+duration). The resolution of the timeout shall be the resolution of the clock on which it is based.</p>
<p>Under no circumstance shall the function fail with a timeout if the mutex can be locked immediately.</p>
<p>As a consequence of the priority inheritance rules (for mutexes initialized with the PRIO_INHERIT protocol), if a timed mutex wait is terminated because its timeout expires, the priority of the owner of the mutex shall be adjusted as necessary to reflect the fact that this thread is no longer among the threads waiting for the mutex.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_timedlock.html"><code>pthread_mutex_timedlock()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). <br />
Differences from the standard:<ul>
<li>the timeout is not expressed as an absolute time point, but as a relative number of timer ticks (by default, the SysTick clock for CMSIS).</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00735">735</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2ca0fafa0ca551bdabe8ca91132df77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::Mutex::try_lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock the mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The mutex was locked. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The state protected by the mutex is not recoverable.. </td></tr>
    <tr><td class="paramname">EAGAIN</td><td>The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The mutex was created with the protocol attribute having the value PTHREAD_PRIO_PROTECT and the calling thread's priority is higher than the mutex's current priority ceiling. </td></tr>
    <tr><td class="paramname">EOWNERDEAD</td><td>The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent. </td></tr>
    <tr><td class="paramname">EDEADLK</td><td>The mutex type is <code>mutex::type::errorcheck</code> and the current thread already owns the mutex. </td></tr>
    <tr><td class="paramname">EBUSY</td><td>The mutex could not be acquired because it was already locked.</td></tr>
  </table>
  </dd>
</dl>
<p>Try to lock the mutex as <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a525b1d221c3ecfac6ccfbb4cc4457c92" title="Lock the mutex. ">lock()</a></code>, except that if the mutex object referenced by mutex is currently locked (by any thread, including the current thread), the call shall return immediately. If the mutex type is <code>mutex::type::recursive</code> and the mutex is currently owned by the calling thread, the mutex lock count shall be incremented by one and the <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#ac2ca0fafa0ca551bdabe8ca91132df77" title="Try to lock the mutex. ">try_lock()</a></code> function shall immediately return success.</p>
<p>If <em>mutex</em> is a robust mutex and the process containing the owning thread terminated while holding the mutex lock, a call to <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#ac2ca0fafa0ca551bdabe8ca91132df77" title="Try to lock the mutex. ">try_lock()</a></code> shall return the error value <code>EOWNERDEAD</code>. If <em>mutex</em> is a robust mutex and the owning thread terminated while holding the mutex lock, a call to <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#ac2ca0fafa0ca551bdabe8ca91132df77" title="Try to lock the mutex. ">try_lock()</a></code> may return the error value <code>EOWNERDEAD</code> even if the process in which the owning thread resides has not terminated. In these cases, the mutex is locked by the thread but the state it protects is marked as inconsistent. The application should ensure that the state is made consistent for reuse and when that is complete call <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a785a59060ced71a2696168cc2a6e6dca" title="Mark mutex as consistent. ">consistent()</a></code>. If the application is unable to recover the state, it should unlock the mutex without a prior call to <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a785a59060ced71a2696168cc2a6e6dca" title="Mark mutex as consistent. ">consistent()</a></code>, after which the mutex is marked permanently unusable.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_trylock.html"><code>pthread_mutex_trylock()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00679">679</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a746365b2ec3520b0795fce1d40937d29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::Mutex::unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The mutex was unlocked. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routine; the mutex type is <code>mutex::type::errorcheck</code> or <code>mutex::type::recursive</code>, or the mutex is a robust mutex, and the current thread does not own the mutex. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The mutex was not unlocked.</td></tr>
  </table>
  </dd>
</dl>
<p>Release the mutex object referenced by <em>mutex</em>. The manner in which a mutex is released is dependent upon the mutex's type attribute. If there are threads blocked on the mutex object referenced by mutex when <code><a class="el" href="classos_1_1rtos_1_1_mutex.html#a746365b2ec3520b0795fce1d40937d29" title="Unlock the mutex. ">unlock()</a></code> is called, resulting in the mutex becoming available, the scheduling policy shall determine which thread shall acquire the mutex.</p>
<p>(In the case of <code>mutex::type::recursive</code> mutexes, the mutex shall become available when the count reaches zero and the calling thread no longer has any locks on this mutex.)</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_unlock.html"><code>pthread_mutex_unlock()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p>Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00817">817</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a76cd88a36e581a1f273affcae7ab4b40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="namespaceos_1_1rtos_1_1mutex.html#a301d03a8d9644b148d90ddb328c91172">mutex::count_t</a> os::rtos::Mutex::count_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="os_8h_source.html#l02757">2757</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7b28039841287b714aee8c8400663334"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">port::Waiting_threads_list os::rtos::Mutex::list_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="os_8h_source.html#l02748">2748</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<a class="anchor" id="aba293f0645e775f3750ab7116f17b163"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceos_1_1rtos_1_1mutex.html#a301d03a8d9644b148d90ddb328c91172">mutex::count_t</a> os::rtos::Mutex::max_count_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="os_8h_source.html#l02767">2767</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad7667db8bf3171d900237500cb0e1e67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char *const os::rtos::Named_object::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to name. </p>
<p>To save space, the null terminated string passed to the constructor is not copied locally. Instead, the pointer to the string is copied, so the caller must ensure that the pointer life cycle is at least as long as the object life cycle. A constant string (stored in flash) is preferred. </p>

<p>Definition at line <a class="el" href="os_8h_source.html#l01122">1122</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<a class="anchor" id="a974b7004fe2325cb1560fb7a3301ae5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classos_1_1rtos_1_1_thread.html">Thread</a>* volatile os::rtos::Mutex::owner_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="os_8h_source.html#l02745">2745</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<a class="anchor" id="a45a04175eec6fe100b4255355490dfc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="group__cmsis-plus-rtos.html#ga1257cd2ea834219f38831bcf66485103">thread::priority_t</a> os::rtos::Mutex::owner_prio_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="os_8h_source.html#l02761">2761</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa3887353afd8a7cfa4190996b49ad3a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="group__cmsis-plus-rtos.html#ga1257cd2ea834219f38831bcf66485103">thread::priority_t</a> os::rtos::Mutex::prio_ceiling_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="os_8h_source.html#l02760">2760</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<a class="anchor" id="a671575343eaa2fbaab379756663f19f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceos_1_1rtos_1_1mutex.html#aafe5223e5997cc46df1ab8e0fd7c1aa9">mutex::protocol_t</a> os::rtos::Mutex::protocol_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="os_8h_source.html#l02765">2765</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad3f33f759c85dffe5b68672fc3f67277"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceos_1_1rtos_1_1mutex.html#aba4f58e0f8e0be35108d2bcd87eb8866">mutex::robustness_t</a> os::rtos::Mutex::robustness_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="os_8h_source.html#l02766">2766</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<a class="anchor" id="a84a88571e9bfcb1b5551b6f0082a6fa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceos_1_1rtos_1_1mutex.html#a3e2a870f9540d3ea14bfcf895bfe611a">mutex::type_t</a> os::rtos::Mutex::type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="os_8h_source.html#l02764">2764</a> of file <a class="el" href="os_8h_source.html">os.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/cmsis-plus/rtos/<a class="el" href="os_8h_source.html">os.h</a></li>
<li>src/cmsis-plus/rtos/<a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceos.html">os</a></li><li class="navelem"><a class="el" href="namespaceos_1_1rtos.html">rtos</a></li><li class="navelem"><a class="el" href="classos_1_1rtos_1_1_mutex.html">Mutex</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
